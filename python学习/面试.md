### 笔试
`staticmethod` 和 `classmethod` 的区别
* 前者的默认参数是 `cls` 和 `self`
* 后者只有 `cls`
<hr>

类变量和实例变量
**记住任何变量再被赋值的时候就会变成局部变量（ `append` 不是赋值）**
```py
class Person:
  name = 'aaa' # 如果是[]列表，则进行append操作不认为是赋值

p1 = Person()
p2 = Person()
p1.name = 'bbb'

p1.name # 'bbb'
p2.name # 'aaa'
Person.name # 'aaa'
```
<hr>

`format` 的用法
```py
`{} and {} is {}`.format((1,2,3)) # 1 and 2 is 3
`{0} and {1} is {2}`.format([1,2,3]) # 支持下标
`{name}`.format(name=1) # 支持关键词参数
`{name}`.format({name:1}) # 支持字典按key
```
<hr>

列表去重
```py
# 利用集合
list(set(l1))

# 利用词典
{}.fromkeys(l1).keys()

# 利用列表推导
l2 = []
[l2.append(i) for i in l1 if not i in l2]
```
<hr>

合并两个有序列表
```py
# 循环算法
def merge_sort(l1, l2):
  tmp = []
  while len(l1)>0 or len(l2)>0 :
    if l1[0] > l2[0]:
      tmp.append(l2[0])
      del l2[0] # 删除
    else:
      tmp.append(l1[0])
      del l1[0] # 删除

  tmp.append(l1)
  tmp.append(l2)
  return tmp
```
<hr>

二分查找
```py
def binarySearch(l, v):
  low, high=0, len(l)-1
  while low < high:
    middle = (low + high) / 2
    if l[mid] > v:
      high = middle
    else if l[mid] < v:
      low = middle
    else:
      return middle
  return low if l[low] = v else False
```
<hr>

利用 `__new__` 实现 `singleton`
这个方法在 `__init__` 之前调用，是类层面上的方法，而后者是实例层面上的方法用于初始化。单例实现方式如下：
```py
class Singleton(object):
    def __new__(cls):
        # 关键在于这，每一次实例化的时候，我们都只会返回这同一个instance对象
        if not hasattr(cls, 'instance'):
            cls.instance = super(Singleton, cls).__new__(cls)
        return cls.instance
```
通过共享同一个实例实现
<hr>

`python my.py v1 v2 `命令运行脚本，通过 `from sys import argv` 如何获得v2的参数值?
```py
argv[2]
```
下列运行结果 `print 1.2 - 1.0 == 0.2`
```py
False # 得到浮点数0.0，再python当中与0不想等
```
下列代码运行结果：
```py
x = 1
def change(a):
    x += 1
    print x
change(x) # 报错，因为一旦赋值，x+=1即x=x+1
# 一旦赋值认为是局部变量，那么x未定义
# 如果是以a改成x传入参数就没有问题，因为x被认为是局部的，在传入参数时就定义好了
```
下列代码运行结果：
```py
print('a'<'b'<'c') # true
print('a'>'b' or 'c') # c
a = (1) # 报错，定义不正确，应该是(1,)
a = '123'
b = '123'
a is b # 这样定义的a，b地址相同，true
```
