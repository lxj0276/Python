### 第8章

#### 标识、相等性、别名
```py
charles = {'born':1832}
lewis = charles
lewis is charles # is判断是否一样的，和__equ__不同
id(lewis), id(charles) # id()函数返回内存地址，进一步说明是否一样
```
所以 `lewis` 和 `charles` 实际上是同一对象的两个别名，对他们的操作都是对对象的操作。
`is` 和 `==` 不同，前者会比较的是标识，后者比较的是值，如果要看是不是 `None` 前面的操作符更快，因为不能重载。

**元组的不可变是相对的。**
```py
t1 = (1, 2, [30, 40])
t1[-1].append(99)
# 元组中不可变的是对象和他的标识，并不是对象的内容不变
# 列表是可变对象，因此可以执行 `append()` 操作。
```

#### 默认浅复制
`Python` 中的复制默认是浅复制，只复制元素引用，节省空间。这样在元素是不可变对象的时候非常节省空间，但是如果是可变对象，如列表的时候，就会出现问题。
```py
l1 = [3, [66, 55, 44], (7, 8, 9)]
l2 = list(l1)
# 此时 l2==l1 但 l2 is not l1

l1.append(100) # l1=[3,[66,55,44],(7,8,9),100]
l1[1].remove(55) # l1=[3,[66,44],(7,8,9),100]
l2[1] += [33,22] # l2=[3,[66,44,33,22],(7,8,9)]
l2[2] += (10,11) # l2=[3,[66,44,33,22],(7,8,9,10,11)]
```
最终 `l1=[3,[66,44,33,22],(7,8,9),100]` 以及 `l2=[3,[66,44,33,22],(7,8,9,10,11)]`
这是因为保存了引用，`l1` 和 `l2` 虽然不是同一列表，但元素是对同一列表 `[66,55,44]` 的引用，所以对这个列表的修改，会同时影响二者，同时列表的 `+=` 运算符就是 `appen()` ，而元组的 `+=` 运算符会生成新的元素，因此导致元组不同，而列表相同的结果。

在**校车类** `bus` 中，保存一个列表，如果使用浅复制就只会复制**列表**的引用，那么对实例 `bus1` 的操作也会影响到 `bus2` ，因此需要使用深复制。
```py
import copy
bus2 = copy.copy(bus1) # 浅复制
bus3 = copy.deepcopy(bus1) # 深复制
```

#### 引用传参
`Python` 的传参方式是共享传参，各个形式参数获得实参中各个引用的副本，因此内部形参实际上实参的别名。下面这个示例说明传参带来的问题。
```py
def f(a, b):
    a += b
    return a

x = 1
y = 2
f(x, y) # 3
x, y # (1,2), 由于是不可变对象，因此a+b生成了一个新对象分配给a

a = [1, 2]
b = [3, 4]
f(a, b) # [1,2,3,4]
a, b # ([1,2,3,4],[3,4])，列表是可变对象，+=会直接append到a后面

a = (1, 2)
b = (3, 4)
f(a ,b) # (1,2,3,4)
a, b # ((1,2),(3,4)), 元组不可变，+=生成新对象
```

#### 不要使用可变类型作为参数默认值
```py
class HauntedBus:
    def __init__(self, passengers=[]):
        self.passengers = passengers
```

这样写会带来问题，因为函数的默认值是在定义函数时计算的，会变成函数对象的属性，因此如果默认值是可变对象，而且修改它的值，会影响到后续的函数调用。最好的办法是将默认参数写成 `None` 然后再函数体中进行判断。

```py
class TwilightBus:
    def __init__(self, passengers = None):
        if passengers is None:
            self.passengers = []
        else:
            self.passengers = passengers

basketball_team = ['Sue', 'Tina']
bus = TwilightBus(basketball_team)
bus.drop('Tina')
basketball_team # ['Sue']
```
即便是这样写，还是有很大风险，因为是引用传参，对内部的修改会影响到原来的参数，可以看到原来 `basketball_team` 中的人**消失了**！
为了避免避免这种情况，只需要改成：`self.passengers = list(passengers)`。
